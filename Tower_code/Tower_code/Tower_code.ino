#include <avr/io.h>
#include <util/delay.h>

#define SIGNAL_PIN PB3 // Выберите пин, который будет использоваться для отправки сигнала
#define ADC_PIN 1 // Используйте нужный аналоговый пин

ADCSRA = (1 << ADEN) | (1 << ADPS1) | (1 << ADPS0); // включить АЦП, предделитель на 8
ADMUX = (1 << REFS0); // используем Vcc как опорное напряжение

uint16_t readADC(uint8_t pin) {
    ADMUX = (ADMUX & 0xF8) | pin; // выбираем канал АЦП
    ADCSRA |= (1 << ADSC); // начинаем преобразование
    while (ADCSRA & (1 << ADSC)); // ожидаем завершения преобразования
    return ADC;
}
void respond() {
  // Подать на пин высокий уровень
  PORTB |= (1 << SIGNAL_PIN);
  // Подождать немного времени, чтобы Arduino успело зарегистрировать сигнал
  _delay_ms(5);
  // Вернуть пин в низкий уровень
  PORTB &= ~(1 << SIGNAL_PIN);
}

uint8_t getAddress() {
    uint16_t adcValue = readADC(ADC_PIN);
    // Преобразуйте adcValue в адрес, используя вашу логику соответствия
    return adcValue/10;//адрес от 0 до 9
}
int main(void) {
  // Настройка пинов, таймеров и прерываний
  // Настройка пина сигнала как выход
  DDRB |= (1 << SIGNAL_PIN);
  // Изначально установить пин в низкий уровень
  PORTB &= ~(1 << SIGNAL_PIN);
  // Имитация задержки, специфичной для слота
  // Например, для слота №1 задержка будет 100 мс, для слота №2 - 200 мс и т.д.
  _delay_ms(getAddress()); //

  respond(); // Отправляем сигнал ответа

  while(1) {
    // Дополнительный код, если необходим
  }
}